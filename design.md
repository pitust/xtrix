# xtrix design
## syscalls
 - triggered with int (10h + syscall number)
 - sysv: rdi is sysno; rsi, rdx, rcx is args; rax is return
 - minimal syscall set:
     - (0) KeLog(len, str*)
     - manipulating VMs
         - (01) KeCreateVM() -> vm
         - (02) KeLoadELF(vm, memref) -> entry
         - (03) KeASLRAddress() -> `addr` which is free in the current process
     - manipulating threads
         - (04) KeReadRegs(thr) -> regs
         - (05) KeWriteRegs(thr, regs)
         - (06) KeCreateThread(vm, rip, rdi, rsi, rdx, rsp) -> thr
         - (07) KeChangeThreadStopCounter(thr, delta) -> thr.counter += delta, thr.counter
         - (08) KeSendSignal(sig, rsi)
         - (09) KeCreateSignal(thr, rip, rdi) -> sig
         - (0a) KeGetSelfThread() -> thr
     - memory objects
         - (0b) KeAllocateMemoryObject(size) -> mem
         - (0c) KeAllocateMemRefObject(addr, size) -> memref
         - (0d) KeGetMemObjectSize(mem | memref) -> int
         - (0e) KeReadMemory(mem | memref, addr, count, outaddr)
         - (0f) KeWriteMemory(mem, addr, count, outaddr)
         - (23) KeMapMemory(vm, mem, addr)
         - (24) KeUnmapMemory(vm, mem)
         - (25) (alt) KeMapMemory(mem, addr)
         - (26) (alt) KeUnmapMemory(mem)
         - (27) KeCreateMemoryForPhys(addr, size) -> mem
         - (28) KeReadPhysicalMemory(addr, size) -> memref
         - (29) (alt) KeReadPhysicalMemory(addr, size, outaddr)
         - (2a) KeLookupPhysicalAddress(mem, page) -> phys
         - (10) KeGetMemoryObjectByAddress(vm, addr, size* | nil) -> mem | nullobj
     - objects
         - (11) KeCloneObject(obj) -> obj
         - (12) KeDeleteObject(handle<obj>)
         - (13) KeRefCount(obj) -> int
         - (14) KeGetType(obj) -> objtype
         - (15) KeIsNull(obj) -> `bool` true if KeGetType(obj) is nullobj, else false
     - channels
         - (16) KeCreateChannel() -> chan
         - (17) KeCreateKeyedChannel(key) -> chan
         - (18) KeDestroyChannel(chan)
         - (19) KeGetChannelByName(name) -> chan
         - (1a) KeMakeInfiniteChannel(chan, isinfinite)
         - (1b) KePushMessage(chan, obj) -> void
         - (1c) KePopMessage(chan) -> obj
         - (1d) KePopMessageAsync(chan, thr, sig) -> obj
     - credentials
         - (1e) KeCreateCred(name) -> cred
         - (1f) KeCredVerity(cred) -> credverity
         - (20) KeCredProve(cred, obj) -> credproof
         - (21) KeCheckCred(credproof, credverity) -> `credproof.obj` if credproof.cred is credverity.cred, nullobj otherwise
         - (22) KeLockNamedChannels(credverity)
 - objects:
     - nullobj
     - mem
         - size
         - phys
     - memref
         - size
         - data*
     - vm
         - { addr, mem }[]
         - pagetable
     - thr
         - obj[512]
         - regs
         - vm
     - chan
         - write: int
         - read: int
         - obj[512]*
         - mode: enum[finite, infinite]
     - cred
         - name (str)
     - credproof
         - cred*
         - obj
     - credverity
         - cred*
 - init is pretty easy:
     - let initelf: memref = module("init.elf")
     - let initrd: memref = module("initrd.bin")
     - let entry = 0
     - let vm = KeCreateVMFromELF(initelf, &entry)
     - let stack = KeASLRAddress(vm)
     - KeAddMemoryObjectToVM(vm, KeAllocateMemoryObject(0x1000), stack)
     - let thr = KeCreateThread(vm, entry, 0, 0, 0, stack + 0x1000)
     - KePushMessage(KeCreateNamedChannel("kernel:initprocess"), thr)
     - KePushMessage(KeCreateNamedChannel("kernel:initrd"), initrd)
